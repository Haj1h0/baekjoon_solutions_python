# 회의가 끝나는 순으로 정렬한다. 빨리 끝날수록 최적이다.
# 가장 빨리 끝나는 회의의 종료시간에만 주목하다가 다음 빨리 끝나는 회의의 시작시간이 해당 종료 시간보다 더 같거나 큰 경우 
# cnt += 1을 진행하고 해당 회의의 종료시간을 주목하는것으로 변경한다.

import sys

input = sys.stdin.readline

def main():

    cnt = 0
  
    A = [tuple(map(int,input().split())) for _ in range(int(input()))]
    A.sort(key = lambda x : (x[1], x[0]))

    val = A[0][1]    # 첫 회의를 이미 “선택한 것처럼” 시작했기에 cnt + 1 
  
    for i in A[1:]:
        if val <= i[0]:
            cnt += 1
            val = i[1]

    return cnt + 1
      
if __name__ == "__main__":
    print(main())

# 최초 아이디어 (오답)
# 회의 시작 순서대로 배치 한 후 stack에 시간 순서대로 넣는다.
# stack에 쌓인 회의 중 한 회의가 종료되면 나머지 존재하던 회의는 사용할 수 없다.
# 하지만 여기서 시간 순서대로 넣을 경우 최대 2^31-1 만큼 이기에 시간 초과 가능성이 존재한다.
# 고로 시간 순서대로 넣는게 아닌 회의 시작 순서대로 스택에 넣는데
# 스택 안에는 종료 시간에 관한 값만 들어간다.
# 들어간 종료 시간이 스택안에서 pop한 가장 작은 종료시간보다 작으면 해당 stack은 터트리고 cnt += 1을 한다.
# stack에 들어가는 조건은 stack이 비어있거나 stack의 종료시간보다 회의 시작시간이 더 작은 경우에 들어간다.
# 만약 회의 시작 시간이 스택의 종료시간보다 r같거나 크다면 해당 stack은 터트리고 새로운 회의를 넣은 후 cnt += 1을 진행한다.
